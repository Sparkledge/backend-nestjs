'*/*',
    'Postman-Token',
    '7e89b792-a308-44c2-91df-f695ce6690c4',
    'Host',
    'localhost:3002',
    'Accept-Encoding',
    'gzip, deflate, br',
    'Connection',
    'keep-alive';
rawTrailers: [],
    aborted;
false,
    upgrade;
false,
    url;
'/users/getPublishedDocumentsByUserId/a91ce4fe-dfda-42a7-820d-98460f1fef86',
    method;
'GET',
    statusCode;
null,
    statusMessage;
null,
    client;
 * 1 > Socket;
{
    connecting: false,
        _hadError;
    false,
        _parent;
    null,
        _host;
    null,
        _readableState;
    ReadableState;
    {
        objectMode: false,
            highWaterMark;
        16384,
            buffer;
        BufferList;
        {
            head: null, tail;
            null, length;
            0;
        }
        length: 0,
            pipes;
        [],
            flowing;
        true,
            ended;
        false,
            endEmitted;
        false,
            reading;
        true,
            constructed;
        true,
            sync;
        false,
            needReadable;
        true,
            emittedReadable;
        false,
            readableListening;
        false,
            resumeScheduled;
        false,
            errorEmitted;
        false,
            emitClose;
        false,
            autoDestroy;
        true,
            destroyed;
        false,
            errored;
        null,
            closed;
        false,
            closeEmitted;
        false,
            defaultEncoding;
        'utf8',
            awaitDrainWriters;
        null,
            multiAwaitDrain;
        false,
            readingMore;
        false,
            dataEmitted;
        false,
            decoder;
        null,
            encoding;
        null,
            [Symbol(kPaused)];
        false;
    }
    _events: [Object, null, prototype];
    {
        end: [Array],
            timeout;
        [Function, socketOnTimeout],
            data;
        [Function, bound, socketOnData],
            error;
        [Function, socketOnError],
            close;
        [Array],
            drain;
        [Function, bound, socketOnDrain],
            resume;
        [Function, onSocketResume],
            pause;
        [Function, onSocketPause];
    }
    _eventsCount: 8,
        _maxListeners;
    undefined,
        _writableState;
    WritableState;
    {
        objectMode: false,
            highWaterMark;
        16384,
            finalCalled;
        false,
            needDrain;
        false,
            ending;
        false,
            ended;
        false,
            finished;
        false,
            destroyed;
        false,
            decodeStrings;
        false,
            defaultEncoding;
        'utf8',
            length;
        0,
            writing;
        false,
            corked;
        0,
            sync;
        true,
            bufferProcessing;
        false,
            onwrite;
        [Function, bound, onwrite],
            writecb;
        null,
            writelen;
        0,
            afterWriteTickInfo;
        null,
            buffered;
        [],
            bufferedIndex;
        0,
            allBuffers;
        true,
            allNoop;
        true,
            pendingcb;
        0,
            constructed;
        true,
            prefinished;
        false,
            errorEmitted;
        false,
            emitClose;
        false,
            autoDestroy;
        true,
            errored;
        null,
            closed;
        false,
            closeEmitted;
        false,
            [Symbol(kOnFinished)];
        [];
    }
    allowHalfOpen: true,
        _sockname;
    null,
        _pendingData;
    null,
        _pendingEncoding;
    '',
        server;
    Server;
    {
        maxHeaderSize: undefined,
            insecureHTTPParser;
        undefined,
            _events;
        [Object, null, prototype],
            _eventsCount;
        2,
            _maxListeners;
        undefined,
            _connections;
        2,
            _handle;
        [TCP],
            _usingWorkers;
        false,
            _workers;
        [],
            _unref;
        false,
            allowHalfOpen;
        true,
            pauseOnConnect;
        false,
            noDelay;
        false,
            keepAlive;
        false,
            keepAliveInitialDelay;
        0,
            httpAllowHalfOpen;
        false,
            timeout;
        0,
            keepAliveTimeout;
        5000,
            maxHeadersCount;
        null,
            maxRequestsPerSocket;
        0,
            headersTimeout;
        60000,
            requestTimeout;
        0,
            _connectionKey;
        '6::::3002',
            [Symbol(IncomingMessage)];
        [Function, IncomingMessage],
            [Symbol(ServerResponse)];
        [Function, ServerResponse],
            [Symbol(kCapture)];
        false,
            [Symbol(async_id_symbol)];
        33,
            [Symbol(kUniqueHeaders)];
        null;
    }
    _server: Server;
    {
        maxHeaderSize: undefined,
            insecureHTTPParser;
        undefined,
            _events;
        [Object, null, prototype],
            _eventsCount;
        2,
            _maxListeners;
        undefined,
            _connections;
        2,
            _handle;
        [TCP],
            _usingWorkers;
        false,
            _workers;
        [],
            _unref;
        false,
            allowHalfOpen;
        true,
            pauseOnConnect;
        false,
            noDelay;
        false,
            keepAlive;
        false,
            keepAliveInitialDelay;
        0,
            httpAllowHalfOpen;
        false,
            timeout;
        0,
            keepAliveTimeout;
        5000,
            maxHeadersCount;
        null,
            maxRequestsPerSocket;
        0,
            headersTimeout;
        60000,
            requestTimeout;
        0,
            _connectionKey;
        '6::::3002',
            [Symbol(IncomingMessage)];
        [Function, IncomingMessage],
            [Symbol(ServerResponse)];
        [Function, ServerResponse],
            [Symbol(kCapture)];
        false,
            [Symbol(async_id_symbol)];
        33,
            [Symbol(kUniqueHeaders)];
        null;
    }
    parser: HTTPParser;
    {
        '0';
        [Function, bound, setRequestTimeout],
            '1';
        [Function, parserOnHeaders],
            '2';
        [Function, parserOnHeadersComplete],
            '3';
        [Function, parserOnBody],
            '4';
        [Function, parserOnMessageComplete],
            '5';
        [Function, bound, onParserExecute],
            '6';
        [Function, bound, onParserTimeout],
            _headers;
        [],
            _url;
        '',
            socket;
        [Circular * 1],
            incoming;
        [Circular * 2],
            outgoing;
        null,
            maxHeaderPairs;
        2000,
            _consumed;
        true,
            onIncoming;
        [Function, bound, parserOnIncoming],
            [Symbol(resource_symbol)];
        [HTTPServerAsyncResource];
    }
    on: [Function, socketListenerWrap],
        addListener;
    [Function, socketListenerWrap],
        prependListener;
    [Function, socketListenerWrap],
        setEncoding;
    [Function, socketSetEncoding],
        _paused;
    false,
        _httpMessage;
    ServerResponse;
    {
        _events: [Object, null, prototype],
            _eventsCount;
        1,
            _maxListeners;
        undefined,
            outputData;
        [],
            outputSize;
        0,
            writable;
        true,
            destroyed;
        false,
            _last;
        false,
            chunkedEncoding;
        false,
            shouldKeepAlive;
        true,
            maxRequestsOnConnectionReached;
        false,
            _defaultKeepAlive;
        true,
            useChunkedEncodingByDefault;
        true,
            sendDate;
        true,
            _removedConnection;
        false,
            _removedContLen;
        false,
            _removedTE;
        false,
            _contentLength;
        null,
            _hasBody;
        true,
            _trailer;
        '',
            finished;
        false,
            _headerSent;
        false,
            _closed;
        false,
            socket;
        [Circular * 1],
            _header;
        null,
            _keepAliveTimeout;
        5000,
            _onPendingData;
        [Function, bound, updateOutgoingData],
            req;
        [Circular * 2],
            _sent100;
        false,
            _expect_continue;
        false,
            locals;
        [Object, null, prototype];
        { }
        [Symbol(kCapture)];
        false,
            [Symbol(kNeedDrain)];
        false,
            [Symbol(corked)];
        0,
            [Symbol(kOutHeaders)];
        [Object, null, prototype],
            [Symbol(kUniqueHeaders)];
        null;
    }
    [Symbol(async_id_symbol)];
    38,
        [Symbol(kHandle)];
    TCP;
    {
        reading: true,
            onconnection;
        null,
            _consumed;
        true,
            [Symbol(owner_symbol)];
        [Circular * 1];
    }
    [Symbol(lastWriteQueueSize)];
    0,
        [Symbol(timeout)];
    null,
        [Symbol(kBuffer)];
    null,
        [Symbol(kBufferCb)];
    null,
        [Symbol(kBufferGen)];
    null,
        [Symbol(kCapture)];
    false,
        [Symbol(kSetNoDelay)];
    false,
        [Symbol(kSetKeepAlive)];
    false,
        [Symbol(kSetKeepAliveInitialDelay)];
    0,
        [Symbol(kBytesRead)];
    0,
        [Symbol(kBytesWritten)];
    0,
        [Symbol(RequestTimeout)];
    undefined;
}
_consuming: false,
    _dumped;
false,
    next;
[Function, next],
    baseUrl;
'',
    originalUrl;
'/users/getPublishedDocumentsByUserId/a91ce4fe-dfda-42a7-820d-98460f1fef86',
    _parsedUrl;
Url;
{
    protocol: null,
        slashes;
    null,
        auth;
    null,
        host;
    null,
        port;
    null,
        hostname;
    null,
        hash;
    null,
        search;
    null,
        query;
    null,
        pathname;
    '/users/getPublishedDocumentsByUserId/a91ce4fe-dfda-42a7-820d-98460f1fef86',
        path;
    '/users/getPublishedDocumentsByUserId/a91ce4fe-dfda-42a7-820d-98460f1fef86',
        href;
    '/users/getPublishedDocumentsByUserId/a91ce4fe-dfda-42a7-820d-98460f1fef86',
        _raw;
    '/users/getPublishedDocumentsByUserId/a91ce4fe-dfda-42a7-820d-98460f1fef86';
}
params: {
    userId: 'a91ce4fe-dfda-42a7-820d-98460f1fef86';
}
query: { }
res:  * 3 > ServerResponse;
{
    _events: [Object, null, prototype];
    {
        finish: [Function, bound, resOnFinish];
    }
    _eventsCount: 1,
        _maxListeners;
    undefined,
        outputData;
    [],
        outputSize;
    0,
        writable;
    true,
        destroyed;
    false,
        _last;
    false,
        chunkedEncoding;
    false,
        shouldKeepAlive;
    true,
        maxRequestsOnConnectionReached;
    false,
        _defaultKeepAlive;
    true,
        useChunkedEncodingByDefault;
    true,
        sendDate;
    true,
        _removedConnection;
    false,
        _removedContLen;
    false,
        _removedTE;
    false,
        _contentLength;
    null,
        _hasBody;
    true,
        _trailer;
    '',
        finished;
    false,
        _headerSent;
    false,
        _closed;
    false,
        socket;
     * 1 > Socket;
    {
        connecting: false,
            _hadError;
        false,
            _parent;
        null,
            _host;
        null,
            _readableState;
        [ReadableState],
            _events;
        [Object, null, prototype],
            _eventsCount;
        8,
            _maxListeners;
        undefined,
            _writableState;
        [WritableState],
            allowHalfOpen;
        true,
            _sockname;
        null,
            _pendingData;
        null,
            _pendingEncoding;
        '',
            server;
        [Server],
            _server;
        [Server],
            parser;
        [HTTPParser],
            on;
        [Function, socketListenerWrap],
            addListener;
        [Function, socketListenerWrap],
            prependListener;
        [Function, socketListenerWrap],
            setEncoding;
        [Function, socketSetEncoding],
            _paused;
        false,
            _httpMessage;
        [Circular * 3],
            [Symbol(async_id_symbol)];
        38,
            [Symbol(kHandle)];
        [TCP],
            [Symbol(lastWriteQueueSize)];
        0,
            [Symbol(timeout)];
        null,
            [Symbol(kBuffer)];
        null,
            [Symbol(kBufferCb)];
        null,
            [Symbol(kBufferGen)];
        null,
            [Symbol(kCapture)];
        false,
            [Symbol(kSetNoDelay)];
        false,
            [Symbol(kSetKeepAlive)];
        false,
            [Symbol(kSetKeepAliveInitialDelay)];
        0,
            [Symbol(kBytesRead)];
        0,
            [Symbol(kBytesWritten)];
        0,
            [Symbol(RequestTimeout)];
        undefined;
    }
    _header: null,
        _keepAliveTimeout;
    5000,
        _onPendingData;
    [Function, bound, updateOutgoingData],
        req;
    [Circular * 2],
        _sent100;
    false,
        _expect_continue;
    false,
        locals;
    [Object, null, prototype];
    { }
    [Symbol(kCapture)];
    false,
        [Symbol(kNeedDrain)];
    false,
        [Symbol(corked)];
    0,
        [Symbol(kOutHeaders)];
    [Object, null, prototype];
    {
        'x-powered-by';
        [Array], vary;
        [Array];
    }
    [Symbol(kUniqueHeaders)];
    null;
}
body: { }
route: Route;
{
    path: '/users/getPublishedDocumentsByUserId/:userId',
        stack;
    [[Layer]],
        methods;
    {
        get: true;
    }
}
[Symbol(kCapture)];
false,
    [Symbol(kHeaders)];
{
    authorization: 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjMzNDc1ODU5LTU3MmUtNGRjZS1hNTc4LWZkM2I5ZjE4OTRlMCIsImVtYWlsIjoiemFrYXJpeWEuZnJ1bWFAZWxlZGVlbi5vcmciLCJpc1ZlcmlmaWVkIjp0cnVlLCJpYXQiOjE2NjU4NDQ3ODYsImV4cCI6MTY2NTg0ODM4Nn0.M6qhqRbx1dnokQ2DJRo4bG0y7UNH6GBpTUb6SQcKgPs',
        'user-agent';
    'PostmanRuntime/7.29.2',
        accept;
    '*/*',
        'postman-token';
    '7e89b792-a308-44c2-91df-f695ce6690c4',
        host;
    'localhost:3002',
        'accept-encoding';
    'gzip, deflate, br',
        connection;
    'keep-alive';
}
[Symbol(kHeadersCount)];
14,
    [Symbol(kTrailers)];
null,
    [Symbol(kTrailersCount)];
0,
    [Symbol(RequestTimeout)];
undefined;
roles['ADMIN'];
request:  * 2 > IncomingMessage;
{
    _readableState: ReadableState;
    {
        objectMode: false,
            highWaterMark;
        16384,
            buffer;
        BufferList;
        {
            head: null, tail;
            null, length;
            0;
        }
        length: 0,
            pipes;
        [],
            flowing;
        null,
            ended;
        true,
            endEmitted;
        false,
            reading;
        false,
            constructed;
        true,
            sync;
        true,
            needReadable;
        false,
            emittedReadable;
        false,
            readableListening;
        false,
            resumeScheduled;
        false,
            errorEmitted;
        false,
            emitClose;
        true,
            autoDestroy;
        true,
            destroyed;
        false,
            errored;
        null,
            closed;
        false,
            closeEmitted;
        false,
            defaultEncoding;
        'utf8',
            awaitDrainWriters;
        null,
            multiAwaitDrain;
        false,
            readingMore;
        true,
            dataEmitted;
        false,
            decoder;
        null,
            encoding;
        null,
            [Symbol(kPaused)];
        null;
    }
    _events: [Object, null, prototype];
    {
        end: [Function, clearRequestTimeout];
    }
    _eventsCount: 1,
        _maxListeners;
    undefined,
        socket;
     * 1 > Socket;
    {
        connecting: false,
            _hadError;
        false,
            _parent;
        null,
            _host;
        null,
            _readableState;
        ReadableState;
        {
            objectMode: false,
                highWaterMark;
            16384,
                buffer;
            BufferList;
            {
                head: null, tail;
                null, length;
                0;
            }
            length: 0,
                pipes;
            [],
                flowing;
            true,
                ended;
            false,
                endEmitted;
            false,
                reading;
            true,
                constructed;
            true,
                sync;
            false,
                needReadable;
            true,
                emittedReadable;
            false,
                readableListening;
            false,
                resumeScheduled;
            false,
                errorEmitted;
            false,
                emitClose;
            false,
                autoDestroy;
            true,
                destroyed;
            false,
                errored;
            null,
                closed;
            false,
                closeEmitted;
            false,
                defaultEncoding;
            'utf8',
                awaitDrainWriters;
            null,
                multiAwaitDrain;
            false,
                readingMore;
            false,
                dataEmitted;
            false,
                decoder;
            null,
                encoding;
            null,
                [Symbol(kPaused)];
            false;
        }
        _events: [Object, null, prototype];
        {
            end: [Array],
                timeout;
            [Function, socketOnTimeout],
                data;
            [Function, bound, socketOnData],
                error;
            [Function, socketOnError],
                close;
            [Array],
                drain;
            [Function, bound, socketOnDrain],
                resume;
            [Function, onSocketResume],
                pause;
            [Function, onSocketPause];
        }
        _eventsCount: 8,
            _maxListeners;
        undefined,
            _writableState;
        WritableState;
        {
            objectMode: false,
                highWaterMark;
            16384,
                finalCalled;
            false,
                needDrain;
            false,
                ending;
            false,
                ended;
            false,
                finished;
            false,
                destroyed;
            false,
                decodeStrings;
            false,
                defaultEncoding;
            'utf8',
                length;
            0,
                writing;
            false,
                corked;
            0,
                sync;
            true,
                bufferProcessing;
            false,
                onwrite;
            [Function, bound, onwrite],
                writecb;
            null,
                writelen;
            0,
                afterWriteTickInfo;
            null,
                buffered;
            [],
                bufferedIndex;
            0,
                allBuffers;
            true,
                allNoop;
            true,
                pendingcb;
            0,
                constructed;
            true,
                prefinished;
            false,
                errorEmitted;
            false,
                emitClose;
            false,
                autoDestroy;
            true,
                errored;
            null,
                closed;
            false,
                closeEmitted;
            false,
                [Symbol(kOnFinished)];
            [];
        }
        allowHalfOpen: true,
            _sockname;
        null,
            _pendingData;
        null,
            _pendingEncoding;
        '',
            server;
        Server;
        {
            maxHeaderSize: undefined,
                insecureHTTPParser;
            undefined,
                _events;
            [Object, null, prototype],
                _eventsCount;
            2,
                _maxListeners;
            undefined,
                _connections;
            2,
                _handle;
            [TCP],
                _usingWorkers;
            false,
                _workers;
            [],
                _unref;
            false,
                allowHalfOpen;
            true,
                pauseOnConnect;
            false,
                noDelay;
            false,
                keepAlive;
            false,
                keepAliveInitialDelay;
            0,
                httpAllowHalfOpen;
            false,
                timeout;
            0,
                keepAliveTimeout;
            5000,
                maxHeadersCount;
            null,
                maxRequestsPerSocket;
            0,
                headersTimeout;
            60000,
                requestTimeout;
            0,
                _connectionKey;
            '6::::3002',
                [Symbol(IncomingMessage)];
            [Function, IncomingMessage],
                [Symbol(ServerResponse)];
            [Function, ServerResponse],
                [Symbol(kCapture)];
            false,
                [Symbol(async_id_symbol)];
            33,
                [Symbol(kUniqueHeaders)];
            null;
        }
        _server: Server;
        {
            maxHeaderSize: undefined,
                insecureHTTPParser;
            undefined,
                _events;
            [Object, null, prototype],
                _eventsCount;
            2,
                _maxListeners;
            undefined,
                _connections;
            2,
                _handle;
            [TCP],
                _usingWorkers;
            false,
                _workers;
            [],
                _unref;
            false,
                allowHalfOpen;
            true,
                pauseOnConnect;
            false,
                noDelay;
            false,
                keepAlive;
            false,
                keepAliveInitialDelay;
            0,
                httpAllowHalfOpen;
            false,
                timeout;
            0,
                keepAliveTimeout;
            5000,
                maxHeadersCount;
            null,
                maxRequestsPerSocket;
            0,
                headersTimeout;
            60000,
                requestTimeout;
            0,
                _connectionKey;
            '6::::3002',
                [Symbol(IncomingMessage)];
            [Function, IncomingMessage],
                [Symbol(ServerResponse)];
            [Function, ServerResponse],
                [Symbol(kCapture)];
            false,
                [Symbol(async_id_symbol)];
            33,
                [Symbol(kUniqueHeaders)];
            null;
        }
        parser: HTTPParser;
        {
            '0';
            [Function, bound, setRequestTimeout],
                '1';
            [Function, parserOnHeaders],
                '2';
            [Function, parserOnHeadersComplete],
                '3';
            [Function, parserOnBody],
                '4';
            [Function, parserOnMessageComplete],
                '5';
            [Function, bound, onParserExecute],
                '6';
            [Function, bound, onParserTimeout],
                _headers;
            [],
                _url;
            '',
                socket;
            [Circular * 1],
                incoming;
            [Circular * 2],
                outgoing;
            null,
                maxHeaderPairs;
            2000,
                _consumed;
            true,
                onIncoming;
            [Function, bound, parserOnIncoming],
                [Symbol(resource_symbol)];
            [HTTPServerAsyncResource];
        }
        on: [Function, socketListenerWrap],
            addListener;
        [Function, socketListenerWrap],
            prependListener;
        [Function, socketListenerWrap],
            setEncoding;
        [Function, socketSetEncoding],
            _paused;
        false,
            _httpMessage;
        ServerResponse;
        {
            _events: [Object, null, prototype],
                _eventsCount;
            1,
                _maxListeners;
            undefined,
                outputData;
            [],
                outputSize;
            0,
                writable;
            true,
                destroyed;
            false,
                _last;
            false,
                chunkedEncoding;
            false,
                shouldKeepAlive;
            true,
                maxRequestsOnConnectionReached;
            false,
                _defaultKeepAlive;
            true,
                useChunkedEncodingByDefault;
            true,
                sendDate;
            true,
                _removedConnection;
            false,
                _removedContLen;
            false,
                _removedTE;
            false,
                _contentLength;
            null,
                _hasBody;
            true,
                _trailer;
            '',
                finished;
            false,
                _headerSent;
            false,
                _closed;
            false,
                socket;
            [Circular * 1],
                _header;
            null,
                _keepAliveTimeout;
            5000,
                _onPendingData;
            [Function, bound, updateOutgoingData],
                req;
            [Circular * 2],
                _sent100;
            false,
                _expect_continue;
            false,
                locals;
            [Object, null, prototype];
            { }
            [Symbol(kCapture)];
            false,
                [Symbol(kNeedDrain)];
            false,
                [Symbol(corked)];
            0,
                [Symbol(kOutHeaders)];
            [Object, null, prototype],
                [Symbol(kUniqueHeaders)];
            null;
        }
        [Symbol(async_id_symbol)];
        38,
            [Symbol(kHandle)];
        TCP;
        {
            reading: true,
                onconnection;
            null,
                _consumed;
            true,
                [Symbol(owner_symbol)];
            [Circular * 1];
        }
        [Symbol(lastWriteQueueSize)];
        0,
            [Symbol(timeout)];
        null,
            [Symbol(kBuffer)];
        null,
            [Symbol(kBufferCb)];
        null,
            [Symbol(kBufferGen)];
        null,
            [Symbol(kCapture)];
        false,
            [Symbol(kSetNoDelay)];
        false,
            [Symbol(kSetKeepAlive)];
        false,
            [Symbol(kSetKeepAliveInitialDelay)];
        0,
            [Symbol(kBytesRead)];
        0,
            [Symbol(kBytesWritten)];
        0,
            [Symbol(RequestTimeout)];
        undefined;
    }
    httpVersionMajor: 1,
        httpVersionMinor;
    1,
        httpVersion;
    '1.1',
        complete;
    true,
        rawHeaders;
    [
        'Authorization',
        'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjMzNDc1ODU5LTU3MmUtNGRjZS1hNTc4LWZkM2I5ZjE4OTRlMCIsImVtYWlsIjoiemFrYXJpeWEuZnJ1bWFAZWxlZGVlbi5vcmciLCJpc1ZlcmlmaWVkIjp0cnVlLCJpYXQiOjE2NjU4NDQ3ODYsImV4cCI6MTY2NTg0ODM4Nn0.M6qhqRbx1dnokQ2DJRo4bG0y7UNH6GBpTUb6SQcKgPs',
        'User-Agent',
        'PostmanRuntime/7.29.2',
        'Accept',
        '*/*',
        'Postman-Token',
        '7e89b792-a308-44c2-91df-f695ce6690c4',
        'Host',
        'localhost:3002',
        'Accept-Encoding',
        'gzip, deflate, br',
        'Connection',
        'keep-alive'
    ],
        rawTrailers;
    [],
        aborted;
    false,
        upgrade;
    false,
        url;
    '/users/getPublishedDocumentsByUserId/a91ce4fe-dfda-42a7-820d-98460f1fef86',
        method;
    'GET',
        statusCode;
    null,
        statusMessage;
    null,
        client;
     * 1 > Socket;
    {
        connecting: false,
            _hadError;
        false,
            _parent;
        null,
            _host;
        null,
            _readableState;
        ReadableState;
        {
            objectMode: false,
                highWaterMark;
            16384,
                buffer;
            BufferList;
            {
                head: null, tail;
                null, length;
                0;
            }
            length: 0,
                pipes;
            [],
                flowing;
            true,
                ended;
            false,
                endEmitted;
            false,
                reading;
            true,
                constructed;
            true,
                sync;
            false,
                needReadable;
            true,
                emittedReadable;
            false,
                readableListening;
            false,
                resumeScheduled;
            false,
                errorEmitted;
            false,
                emitClose;
            false,
                autoDestroy;
            true,
                destroyed;
            false,
                errored;
            null,
                closed;
            false,
                closeEmitted;
            false,
                defaultEncoding;
            'utf8',
                awaitDrainWriters;
            null,
                multiAwaitDrain;
            false,
                readingMore;
            false,
                dataEmitted;
            false,
                decoder;
            null,
                encoding;
            null,
                [Symbol(kPaused)];
            false;
        }
        _events: [Object, null, prototype];
        {
            end: [Array],
                timeout;
            [Function, socketOnTimeout],
                data;
            [Function, bound, socketOnData],
                error;
            [Function, socketOnError],
                close;
            [Array],
                drain;
            [Function, bound, socketOnDrain],
                resume;
            [Function, onSocketResume],
                pause;
            [Function, onSocketPause];
        }
        _eventsCount: 8,
            _maxListeners;
        undefined,
            _writableState;
        WritableState;
        {
            objectMode: false,
                highWaterMark;
            16384,
                finalCalled;
            false,
                needDrain;
            false,
                ending;
            false,
                ended;
            false,
                finished;
            false,
                destroyed;
            false,
                decodeStrings;
            false,
                defaultEncoding;
            'utf8',
                length;
            0,
                writing;
            false,
                corked;
            0,
                sync;
            true,
                bufferProcessing;
            false,
                onwrite;
            [Function, bound, onwrite],
                writecb;
            null,
                writelen;
            0,
                afterWriteTickInfo;
            null,
                buffered;
            [],
                bufferedIndex;
            0,
                allBuffers;
            true,
                allNoop;
            true,
                pendingcb;
            0,
                constructed;
            true,
                prefinished;
            false,
                errorEmitted;
            false,
                emitClose;
            false,
                autoDestroy;
            true,
                errored;
            null,
                closed;
            false,
                closeEmitted;
            false,
                [Symbol(kOnFinished)];
            [];
        }
        allowHalfOpen: true,
            _sockname;
        null,
            _pendingData;
        null,
            _pendingEncoding;
        '',
            server;
        Server;
        {
            maxHeaderSize: undefined,
                insecureHTTPParser;
            undefined,
                _events;
            [Object, null, prototype],
                _eventsCount;
            2,
                _maxListeners;
            undefined,
                _connections;
            2,
                _handle;
            [TCP],
                _usingWorkers;
            false,
                _workers;
            [],
                _unref;
            false,
                allowHalfOpen;
            true,
                pauseOnConnect;
            false,
                noDelay;
            false,
                keepAlive;
            false,
                keepAliveInitialDelay;
            0,
                httpAllowHalfOpen;
            false,
                timeout;
            0,
                keepAliveTimeout;
            5000,
                maxHeadersCount;
            null,
                maxRequestsPerSocket;
            0,
                headersTimeout;
            60000,
                requestTimeout;
            0,
                _connectionKey;
            '6::::3002',
                [Symbol(IncomingMessage)];
            [Function, IncomingMessage],
                [Symbol(ServerResponse)];
            [Function, ServerResponse],
                [Symbol(kCapture)];
            false,
                [Symbol(async_id_symbol)];
            33,
                [Symbol(kUniqueHeaders)];
            null;
        }
        _server: Server;
        {
            maxHeaderSize: undefined,
                insecureHTTPParser;
            undefined,
                _events;
            [Object, null, prototype],
                _eventsCount;
            2,
                _maxListeners;
            undefined,
                _connections;
            2,
                _handle;
            [TCP],
                _usingWorkers;
            false,
                _workers;
            [],
                _unref;
            false,
                allowHalfOpen;
            true,
                pauseOnConnect;
            false,
                noDelay;
            false,
                keepAlive;
            false,
                keepAliveInitialDelay;
            0,
                httpAllowHalfOpen;
            false,
                timeout;
            0,
                keepAliveTimeout;
            5000,
                maxHeadersCount;
            null,
                maxRequestsPerSocket;
            0,
                headersTimeout;
            60000,
                requestTimeout;
            0,
                _connectionKey;
            '6::::3002',
                [Symbol(IncomingMessage)];
            [Function, IncomingMessage],
                [Symbol(ServerResponse)];
            [Function, ServerResponse],
                [Symbol(kCapture)];
            false,
                [Symbol(async_id_symbol)];
            33,
                [Symbol(kUniqueHeaders)];
            null;
        }
        parser: HTTPParser;
        {
            '0';
            [Function, bound, setRequestTimeout],
                '1';
            [Function, parserOnHeaders],
                '2';
            [Function, parserOnHeadersComplete],
                '3';
            [Function, parserOnBody],
                '4';
            [Function, parserOnMessageComplete],
                '5';
            [Function, bound, onParserExecute],
                '6';
            [Function, bound, onParserTimeout],
                _headers;
            [],
                _url;
            '',
                socket;
            [Circular * 1],
                incoming;
            [Circular * 2],
                outgoing;
            null,
                maxHeaderPairs;
            2000,
                _consumed;
            true,
                onIncoming;
            [Function, bound, parserOnIncoming],
                [Symbol(resource_symbol)];
            [HTTPServerAsyncResource];
        }
        on: [Function, socketListenerWrap],
            addListener;
        [Function, socketListenerWrap],
            prependListener;
        [Function, socketListenerWrap],
            setEncoding;
        [Function, socketSetEncoding],
            _paused;
        false,
            _httpMessage;
        ServerResponse;
        {
            _events: [Object, null, prototype],
                _eventsCount;
            1,
                _maxListeners;
            undefined,
                outputData;
            [],
                outputSize;
            0,
                writable;
            true,
                destroyed;
            false,
                _last;
            false,
                chunkedEncoding;
            false,
                shouldKeepAlive;
            true,
                maxRequestsOnConnectionReached;
            false,
                _defaultKeepAlive;
            true,
                useChunkedEncodingByDefault;
            true,
                sendDate;
            true,
                _removedConnection;
            false,
                _removedContLen;
            false,
                _removedTE;
            false,
                _contentLength;
            null,
                _hasBody;
            true,
                _trailer;
            '',
                finished;
            false,
                _headerSent;
            false,
                _closed;
            false,
                socket;
            [Circular * 1],
                _header;
            null,
                _keepAliveTimeout;
            5000,
                _onPendingData;
            [Function, bound, updateOutgoingData],
                req;
            [Circular * 2],
                _sent100;
            false,
                _expect_continue;
            false,
                locals;
            [Object, null, prototype];
            { }
            [Symbol(kCapture)];
            false,
                [Symbol(kNeedDrain)];
            false,
                [Symbol(corked)];
            0,
                [Symbol(kOutHeaders)];
            [Object, null, prototype],
                [Symbol(kUniqueHeaders)];
            null;
        }
        [Symbol(async_id_symbol)];
        38,
            [Symbol(kHandle)];
        TCP;
        {
            reading: true,
                onconnection;
            null,
                _consumed;
            true,
                [Symbol(owner_symbol)];
            [Circular * 1];
        }
        [Symbol(lastWriteQueueSize)];
        0,
            [Symbol(timeout)];
        null,
            [Symbol(kBuffer)];
        null,
            [Symbol(kBufferCb)];
        null,
            [Symbol(kBufferGen)];
        null,
            [Symbol(kCapture)];
        false,
            [Symbol(kSetNoDelay)];
        false,
            [Symbol(kSetKeepAlive)];
        false,
            [Symbol(kSetKeepAliveInitialDelay)];
        0,
            [Symbol(kBytesRead)];
        0,
            [Symbol(kBytesWritten)];
        0,
            [Symbol(RequestTimeout)];
        undefined;
    }
    _consuming: false,
        _dumped;
    false,
        next;
    [Function, next],
        baseUrl;
    '',
        originalUrl;
    '/users/getPublishedDocumentsByUserId/a91ce4fe-dfda-42a7-820d-98460f1fef86',
        _parsedUrl;
    Url;
    {
        protocol: null,
            slashes;
        null,
            auth;
        null,
            host;
        null,
            port;
        null,
            hostname;
        null,
            hash;
        null,
            search;
        null,
            query;
        null,
            pathname;
        '/users/getPublishedDocumentsByUserId/a91ce4fe-dfda-42a7-820d-98460f1fef86',
            path;
        '/users/getPublishedDocumentsByUserId/a91ce4fe-dfda-42a7-820d-98460f1fef86',
            href;
        '/users/getPublishedDocumentsByUserId/a91ce4fe-dfda-42a7-820d-98460f1fef86',
            _raw;
        '/users/getPublishedDocumentsByUserId/a91ce4fe-dfda-42a7-820d-98460f1fef86';
    }
    params: {
        userId: 'a91ce4fe-dfda-42a7-820d-98460f1fef86';
    }
    query: { }
    res:  * 3 > ServerResponse;
    {
        _events: [Object, null, prototype];
        {
            finish: [Function, bound, resOnFinish];
        }
        _eventsCount: 1,
            _maxListeners;
        undefined,
            outputData;
        [],
            outputSize;
        0,
            writable;
        true,
            destroyed;
        false,
            _last;
        false,
            chunkedEncoding;
        false,
            shouldKeepAlive;
        true,
            maxRequestsOnConnectionReached;
        false,
            _defaultKeepAlive;
        true,
            useChunkedEncodingByDefault;
        true,
            sendDate;
        true,
            _removedConnection;
        false,
            _removedContLen;
        false,
            _removedTE;
        false,
            _contentLength;
        null,
            _hasBody;
        true,
            _trailer;
        '',
            finished;
        false,
            _headerSent;
        false,
            _closed;
        false,
            socket;
         * 1 > Socket;
        {
            connecting: false,
                _hadError;
            false,
                _parent;
            null,
                _host;
            null,
                _readableState;
            [ReadableState],
                _events;
            [Object, null, prototype],
                _eventsCount;
            8,
                _maxListeners;
            undefined,
                _writableState;
            [WritableState],
                allowHalfOpen;
            true,
                _sockname;
            null,
                _pendingData;
            null,
                _pendingEncoding;
            '',
                server;
            [Server],
                _server;
            [Server],
                parser;
            [HTTPParser],
                on;
            [Function, socketListenerWrap],
                addListener;
            [Function, socketListenerWrap],
                prependListener;
            [Function, socketListenerWrap],
                setEncoding;
            [Function, socketSetEncoding],
                _paused;
            false,
                _httpMessage;
            [Circular * 3],
                [Symbol(async_id_symbol)];
            38,
                [Symbol(kHandle)];
            [TCP],
                [Symbol(lastWriteQueueSize)];
            0,
                [Symbol(timeout)];
            null,
                [Symbol(kBuffer)];
            null,
                [Symbol(kBufferCb)];
            null,
                [Symbol(kBufferGen)];
            null,
                [Symbol(kCapture)];
            false,
                [Symbol(kSetNoDelay)];
            false,
                [Symbol(kSetKeepAlive)];
            false,
                [Symbol(kSetKeepAliveInitialDelay)];
            0,
                [Symbol(kBytesRead)];
            0,
                [Symbol(kBytesWritten)];
            0,
                [Symbol(RequestTimeout)];
            undefined;
        }
        _header: null,
            _keepAliveTimeout;
        5000,
            _onPendingData;
        [Function, bound, updateOutgoingData],
            req;
        [Circular * 2],
            _sent100;
        false,
            _expect_continue;
        false,
            locals;
        [Object, null, prototype];
        { }
        [Symbol(kCapture)];
        false,
            [Symbol(kNeedDrain)];
        false,
            [Symbol(corked)];
        0,
            [Symbol(kOutHeaders)];
        [Object, null, prototype];
        {
            'x-powered-by';
            [Array], vary;
            [Array];
        }
        [Symbol(kUniqueHeaders)];
        null;
    }
    body: { }
    route: Route;
    {
        path: '/users/getPublishedDocumentsByUserId/:userId',
            stack;
        [[Layer]],
            methods;
        {
            get: true;
        }
    }
    [Symbol(kCapture)];
    false,
        [Symbol(kHeaders)];
    {
        authorization: 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjMzNDc1ODU5LTU3MmUtNGRjZS1hNTc4LWZkM2I5ZjE4OTRlMCIsImVtYWlsIjoiemFrYXJpeWEuZnJ1bWFAZWxlZGVlbi5vcmciLCJpc1ZlcmlmaWVkIjp0cnVlLCJpYXQiOjE2NjU4NDQ3ODYsImV4cCI6MTY2NTg0ODM4Nn0.M6qhqRbx1dnokQ2DJRo4bG0y7UNH6GBpTUb6SQcKgPs',
            'user-agent';
        'PostmanRuntime/7.29.2',
            accept;
        '*/*',
            'postman-token';
        '7e89b792-a308-44c2-91df-f695ce6690c4',
            host;
        'localhost:3002',
            'accept-encoding';
        'gzip, deflate, br',
            connection;
        'keep-alive';
    }
    [Symbol(kHeadersCount)];
    14,
        [Symbol(kTrailers)];
    null,
        [Symbol(kTrailersCount)];
    0,
        [Symbol(RequestTimeout)];
    undefined;
}
//# sourceMappingURL=elo.js.map